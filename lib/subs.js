import {
  Browsers,
  makeWASocket,
  useMultiFileAuthState,
  fetchLatestBaileysVersion,
  makeCacheableSignalKeyStore,
  DisconnectReason,
  jidDecode,
} from '@whiskeysockets/baileys';
import qrcode from "qrcode"
import NodeCache from 'node-cache';
import main from '../main.js'
import events from '../commands/events.js'
import pino from 'pino';
import fs from 'fs';
import chalk from 'chalk';
import {smsg} from './message.js';
import moment from 'moment-timezone';

if (!global.conns) global.conns = []
const msgRetryCounterCache = new NodeCache({ stdTTL: 0, checkperiod: 0 });
const userDevicesCache = new NodeCache({ stdTTL: 0, checkperiod: 0 });
const groupCache = new NodeCache({ stdTTL: 3600, checkperiod: 300 });
let reintentos = {}

const cleanJid = (jid = '') => jid.replace(/:\d+/, '').split('@')[0]

export async function startSubBot(
  m,
  client,
  caption = '',
  isCode = false,
  phone = '',
  chatId = '',
  commandFlags = {},
  isCommand = false,
) {

  const id = phone || (m?.sender || '').split('@')[0]
  const senderId = m?.sender

  // --- LÓGICA DE CARPETA PREMIUM ---
  const isPremium = commandFlags[senderId]?.isPremium
  const baseFolder = isPremium ? './Sessions/Premium' : './Sessions/Subs'
  const sessionFolder = `${baseFolder}/${id}`

  // Crear la carpeta si no existe
  if (!fs.existsSync(baseFolder)) fs.mkdirSync(baseFolder, { recursive: true })
  // ----------------------------------

  const { state, saveCreds } = await useMultiFileAuthState(sessionFolder)
  const { version } = await fetchLatestBaileysVersion()

  console.info = () => {} 
const sock = makeWASocket({
  logger: pino({ level: 'silent' }),
  printQRInTerminal: false,
  browser: Browsers.macOS('Chrome'),
  auth: state,
  markOnlineOnConnect: true,
  generateHighQualityLinkPreview: true,
  syncFullHistory: false,
  getMessage: async () => '',
  msgRetryCounterCache,
  userDevicesCache,
  cachedGroupMetadata: async (jid) => groupCache.get(jid),
  version,
  keepAliveIntervalMs: 60_000,
  maxIdleTimeMs: 120_000,
  })

  sock.isInit = false
  sock.ev.on('creds.update', saveCreds)

  sock.decodeJid = (jid) => {
    if (!jid) return jid
    if (/:\d+@/gi.test(jid)) {
      let decode = jidDecode(jid) || {}
      return (decode.user && decode.server && decode.user + '@' + decode.server) || jid
    } else return jid
  }

  sock.ev.on('connection.update', async ({ connection, lastDisconnect, isNewLogin, qr }) => {
    if (isNewLogin) sock.isInit = false

    if (connection === 'open') {
      sock.uptime = Date.now();
      sock.isInit = true
      sock.userId = cleanJid(sock.user?.id?.split('@')[0])
      const botDir = sock.userId + '@s.whatsapp.net'
      if (!globalThis.db.data.settings[botDir]) {
        globalThis.db.data.settings[botDir] = {}
      }
      globalThis.db.data.settings[botDir].botmod = false
      globalThis.db.data.settings[botDir].botprem = isPremium ? true : false
      globalThis.db.data.settings[botDir].type = isPremium ? 'Premium' : 'Sub'

      if (!global.conns.find((c) => c.userId === sock.userId)) {
        global.conns.push(sock)
      }

      delete reintentos[sock.userId || id]
      console.log(chalk.bold.green(`[ ✿  ]  BOT ${isPremium ? 'PREMIUM' : 'SUB'} conectado: ${sock.userId}`))

    }

    if (connection === 'close') {
      const botId = sock.userId || id
      const reason = lastDisconnect?.error?.output?.statusCode || lastDisconnect?.reason || 0
      const intentos = reintentos[botId] || 0
      reintentos[botId] = intentos + 1

      if ([401, 403].includes(reason)) {
        if (intentos < 5) {
          console.log(chalk.gray(`[ ✿  ]  Reintentando conexión... ${intentos}/5`))
          setTimeout(() => {
            startSubBot(m, client, caption, isCode, phone, chatId, commandFlags, isCommand)
          }, 3000)
        } else {
          try {
            fs.rmSync(sessionFolder, { recursive: true, force: true })
          } catch (e) {}
          delete reintentos[botId]
        }
        return
      }

      if ([DisconnectReason.connectionClosed, DisconnectReason.connectionLost, DisconnectReason.timedOut, DisconnectReason.connectionReplaced].includes(reason)) {
        setTimeout(() => {
          startSubBot(m, client, caption, isCode, phone, chatId, commandFlags, isCommand)
        }, 3000)
        return
      }

      setTimeout(() => {
        startSubBot(m, client, caption, isCode, phone, chatId, commandFlags, isCommand)
      }, 3000)
    }

if (qr && isCode && phone && client && chatId && commandFlags[senderId]) {
try {
let codeGen = await sock.requestPairingCode(phone, 'ABCD1234');
codeGen = codeGen.match(/.{1,4}/g)?.join("-") || codeGen;
const msg = await m.reply(caption)
const msgCode = await m.reply(codeGen);
delete commandFlags[senderId];
setTimeout(async () => {
try {
await client.sendMessage(chatId, { delete: msg.key });
await client.sendMessage(chatId, { delete: msgCode.key });
} catch {}
}, 60000);
} catch (err) {
console.error("[Código Error]", err);
}}
if (qr && !isCode && client && chatId && commandFlags[senderId]) {
try {
const msgQR = await client.sendMessage(m.chat, { image: await qrcode.toBuffer(qr, { scale: 8 }), caption }, { quoted: m})
delete commandFlags[senderId]
setTimeout(async () => {
try {
await client.sendMessage(chatId, { delete: msgQR.key })
} catch {}
}, 60000)
} catch (err) {
console.error("[QR Error]", err)
}}
});

  sock.ev.on('messages.upsert', async ({ messages, type }) => {
    if (type !== 'notify') return
    for (let raw of messages) {
      if (!raw.message) continue
      let msg = await smsg(sock, raw)
      try {
        main(sock, msg, messages)
      } catch (err) {
        console.log(chalk.gray(`[ ✿  ]  Sub » ${err}`))
      }
    }
  })
 
  try {
  await events(sock, m)
  } catch (err) {
   console.log(chalk.gray(`[ BOT  ]  → ${err}`))
  }

  process.on('uncaughtException', console.error)
   return sock
}

async function joinChannels(client) {
for (const value of Object.values(global.my)) {
if (typeof value === 'string' && value.endsWith('@newsletter')) {
await client.newsletterFollow(value).catch(err => console.log(chalk.gray(`\n[ ✿ ] Error al seguir el canal ${value}`)))
}}}
